use crate::schema::{
    ArrayCount, Field, FieldSwitch, FieldType, Packet, PacketDirection, ProtocolVersion,
    VoidableType,
};
use displaydoc::Display;
use inflector::Inflector;

use std::fs::File;
use std::io::Write;
use std::path::{Path, PathBuf};

use std::borrow::Cow;
use std::fmt::{Display, Formatter};
use std::process::Command;
use thiserror::Error;

#[derive(Debug)]
pub struct ModuleGenerator<'a> {
    module_dir: PathBuf,
    version: &'a ProtocolVersion,
}

pub struct StateGenerator {
    file: File,
    file_path: PathBuf,
    current_mod: Option<PacketDirection>,
    protocol_version: u32,
}

#[derive(Debug, Display, Error)]
pub enum GeneratorError {
    /// IO error: {0}
    #[error(transparent)]
    Io(#[from] std::io::Error),

    /// Path given is not a directory
    NotADir,

    /// Invalid identifier '{0}'
    BadIdent(String),

    /// Error running rustfmt: {0}
    Rustfmt(#[source] std::io::Error),

    /// Rustfmt failed: {0}
    RustfmtExit(RustfmtExit),
}

#[derive(Debug)]
pub struct RustfmtExit(Option<i32>);

pub type GeneratorResult<T> = Result<T, GeneratorError>;

#[derive(Debug)]
enum VariantKind {
    Default,
    Standard,
}

#[derive(Debug)]
enum VariantType {
    Unit,
    Unimplemented,
    Present(RustType),
}

/// Enum field type generated per switch field
#[derive(Debug)]
struct VariableType {
    ident: String,
    /// ((field name, filter value), _, _)
    variants: Vec<((String, String), VariantType, VariantKind)>,
    needs_default_unit: bool,
}

#[derive(Debug)]
enum RustType {
    Plain(Cow<'static, str>),
    Generated(VariableType),
}

// TODO need to use chat types instead of string types

const COMMON_HEADER: &str = "// autogenerated file\n#![allow(unused_imports)]\n";
const INCLUDES: &str = r#"
use crate::types::*;
use minecraft_server_protocol_derive::{ClientBoundPacket, ServerBoundPacket};
use async_std::io::{Cursor, prelude::*};
use std::fmt::{Display, Formatter};
use async_trait::async_trait;

"#;

impl<'a> ModuleGenerator<'a> {
    /// Module dir will be **deleted** and have mod.rs created
    pub fn new(
        module_dir: impl Into<PathBuf>,
        version: &'a ProtocolVersion,
    ) -> GeneratorResult<Self> {
        let module_dir = module_dir.into();
        if module_dir.exists() && !module_dir.is_dir() {
            return Err(GeneratorError::NotADir);
        }

        if module_dir.exists() {
            std::fs::remove_dir_all(&module_dir)?;
        }
        std::fs::create_dir_all(&module_dir)?;

        let generator = Self {
            module_dir,
            version,
        };
        generator.emit_version_constants()?;

        Ok(generator)
    }

    fn emit_version_constants(&self) -> GeneratorResult<()> {
        let mut mod_rs = self.append_to_mod_rs()?;

        writeln!(
            mod_rs,
            r#"
pub const GAME_VERSION: &str = {:?};
pub const MAJOR_GAME_VERSION: &str = {:?};
pub const PROTOCOL_VERSION: u32 = {};
"#,
            self.version.mc_version, self.version.major_version, self.version.version
        )?;

        Ok(())
    }

    pub fn emit_state(&mut self, state: &str) -> GeneratorResult<StateGenerator> {
        let mut mod_rs = self.append_to_mod_rs()?;
        writeln!(&mut mod_rs, "pub mod {};", state)?;
        StateGenerator::new(&self.module_dir, state, self.version).map_err(Into::into)
    }

    fn append_to_mod_rs(&self) -> GeneratorResult<impl std::io::Write> {
        let path = self.module_dir.join("mod.rs");
        let existed = path.exists();
        let mut file = std::fs::OpenOptions::new()
            .create(true)
            .append(true)
            .open(path)?;

        if !existed {
            file.write_all(COMMON_HEADER.as_ref())?;
        }

        Ok(file)
    }
}

const VOID_VARIANT: &str = "NotPresent";

impl StateGenerator {
    fn new(mod_dir: &Path, state: &str, version: &ProtocolVersion) -> std::io::Result<Self> {
        let file_name = {
            let mut name = PathBuf::from(state.to_lowercase());
            name.set_extension("rs");
            name
        };
        let file_path = mod_dir.join(file_name);
        let mut file = std::fs::OpenOptions::new()
            .create_new(true)
            .write(true)
            .open(&file_path)?;

        file.write_all(COMMON_HEADER.as_ref())?;
        file.write_all(INCLUDES.as_ref())?;
        Ok(Self {
            file,
            file_path,
            current_mod: None,
            protocol_version: version.version,
        })
    }

    pub fn emit_packet(&mut self, packet: &Packet) -> GeneratorResult<()> {
        if self.current_mod != Some(packet.direction) {
            // new mod
            if self.current_mod.is_some() {
                writeln!(&mut self.file, "}}\n")?;
            }

            let mod_name = match packet.direction {
                PacketDirection::Clientbound => "client",
                PacketDirection::Serverbound => "server",
            };
            writeln!(&mut self.file, "pub mod {} {{\nuse super::*;\n", mod_name)?;
            self.current_mod = Some(packet.direction);
        }

        let struct_name = packet.name.to_pascal_case();
        let derive = match packet.direction {
            PacketDirection::Clientbound => "ClientBoundPacket",
            PacketDirection::Serverbound => "ServerBoundPacket",
        };

        let field_types = packet
            .fields
            .iter()
            .map(|f| {
                RustType::from_field(
                    FieldTypeSerialization::GenerateVariableTypes(&f, packet),
                    self.protocol_version,
                )
            })
            .collect::<Vec<_>>();
        let is_incomplete = field_types.iter().any(|ty| ty.is_none());

        if is_incomplete {
            writeln!(&mut self.file, "/* TODO incomplete struct {}", struct_name)?;
        }

        writeln!(
            &mut self.file,
            "#[derive({derive})]\n#[packet_id = {id:#04x}]\npub struct {name} {{",
            derive = derive,
            id = packet.id,
            name = struct_name
        )?;

        for (field, ty) in packet.fields.iter().zip(field_types.iter()) {
            let field_name: syn::Ident = {
                let name = field.name.to_snake_case();
                syn::parse_str(&name)
                    .or_else(|_| syn::parse_str(&format!("r#{}", name)))
                    .map_err(|_| GeneratorError::BadIdent(field.name.to_owned()))?
            };

            let comment = if ty.is_none() {
                // not implemented
                "// TODO "
            } else {
                ""
            };

            write!(&mut self.file, "\t{}pub {}: ", comment, field_name)?;

            match ty {
                Some(ty) => {
                    writeln!(&mut self.file, "{},", ty.ident())
                }
                None => {
                    writeln!(&mut self.file, "{},", field.r#type)
                }
            }?;
        }

        let suffix = if is_incomplete { "*/" } else { "" };
        writeln!(&mut self.file, "}}{}\n", suffix)?;

        // generate types for variable fields
        // TODO docstring
        for var_type in field_types.iter().filter_map(|f| {
            if let Some(RustType::Generated(variable)) = f {
                Some(variable)
            } else {
                None
            }
        }) {
            // writeln!(&mut self.file, "/// {:?}", var_type)?;
            writeln!(&mut self.file, "pub enum {} {{", var_type.ident)?;

            // TODO need to implement Field for enums
            const VARIANT_NAMES: [&str; 6] = ["One", "Two", "Three", "Four", "Five", "Six"];
            let mut variant_names = VARIANT_NAMES.iter();
            for ((predicate_field, filter), ty, kind) in &var_type.variants {
                let variant_name = match kind {
                    VariantKind::Standard => {
                        *variant_names.next().expect("ran out of variant names")
                    }
                    VariantKind::Default => "Default",
                };
                match ty {
                    VariantType::Unimplemented => {
                        writeln!(&mut self.file, "// TODO {}(...)", variant_name)
                    }
                    VariantType::Present(ty) => writeln!(
                        &mut self.file,
                        "/// {}={}\n{}({}),",
                        predicate_field,
                        filter,
                        variant_name,
                        ty.ident()
                    ),
                    VariantType::Unit => writeln!(
                        &mut self.file,
                        "/// {}={}\n{},",
                        predicate_field, filter, variant_name
                    ),
                }?
            }

            if var_type.needs_default_unit {
                writeln!(&mut self.file, "{},", VOID_VARIANT)?;
            }

            writeln!(&mut self.file, "}}\n")?;

            writeln!(
                &mut self.file,
                r#"
impl Display for {0} {{
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {{
        f.write_str("{0}") // TODO better display for autogenerated types
    }}
}}"#,
                var_type.ident
            )?;

            writeln!(
                &mut self.file,
                r#"
#[async_trait]
impl Field for {0} {{
    type Displayable = Self;

    fn value(&self) -> &Self::Displayable {{
        self
    }}

    fn size(&self) -> usize {{
        todo!()
    }}

    async fn read_field<R: Read + Unpin + Send>(_r: &mut R) -> PacketResult<Self> {{
        todo!()
    }}

    async fn write_field<W: Write + Unpin + Send>(&self, _w: &mut W) -> PacketResult<()> {{
        todo!()
    }}

}}"#,
                var_type.ident
            )?;
        }

        Ok(())
    }

    pub fn finish(mut self) -> GeneratorResult<()> {
        if self.current_mod.is_some() {
            writeln!(&mut self.file, "}}\n")?;
        }

        drop(self.file);
        rustfmt(&self.file_path)?;

        Ok(())
    }
}

fn rustfmt(file: &Path) -> GeneratorResult<()> {
    let exit = Command::new("rustfmt")
        .args(&["--edition", "2018"])
        .arg(file)
        .spawn()
        .and_then(|mut child| child.wait())
        .map_err(GeneratorError::Rustfmt)?;

    if exit.success() {
        Ok(())
    } else {
        Err(GeneratorError::RustfmtExit(RustfmtExit(exit.code())))
    }
}

impl Display for RustfmtExit {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        if let Some(code) = self.0 {
            write!(f, "exited with code {}", code)
        } else {
            write!(f, "terminated by signal")
        }
    }
}

enum FieldTypeSerialization<'a> {
    GenerateVariableTypes(&'a Field<'a>, &'a Packet<'a>),
    /// e.g. nested array type. field 0 overrides field.type
    GenerateVariableTypesCompound(&'a FieldType, &'a Field<'a>, &'a Packet<'a>),
    PlainOnly(&'a FieldType),
}

impl<'a> FieldTypeSerialization<'a> {
    fn nest(&self, nested_type: &'a FieldType) -> Self {
        use FieldTypeSerialization::*;
        match self {
            GenerateVariableTypes(field, packet)
            | GenerateVariableTypesCompound(_, field, packet) => {
                GenerateVariableTypesCompound(nested_type, field, packet)
            }
            PlainOnly(_) => PlainOnly(nested_type),
        }
    }
}

impl RustType {
    /// Serializes to Rust type, returns None if not implemented
    fn from_field(field: FieldTypeSerialization, protocol_version: u32) -> Option<Self> {
        use FieldType::*;
        use FieldTypeSerialization::*;

        let ty = match field {
            GenerateVariableTypes(field, _) => &field.r#type,
            GenerateVariableTypesCompound(ty, _, _) | PlainOnly(ty) => ty,
        };

        Some(match ty {
            Varint => "VarIntField".into(),
            U16 => "UShortField".into(),
            U8 => "UByteField".into(),
            I64 => "LongField".into(),
            I32 => "IntField".into(),
            I8 => "ByteField".into(),
            I16 => "ShortField".into(),
            F32 => "FloatField".into(),
            F64 => "DoubleField".into(),
            Bool => "BoolField".into(),
            String => "StringField".into(),
            Buffer { count_ty } if matches!(**count_ty, FieldType::Varint) => {
                "VarIntThenByteArrayField".into()
            }
            Array { count, elem_ty } => {
                let elem_ty = Self::from_field(field.nest(elem_ty), protocol_version)?;
                match count {
                    ArrayCount::Constant(n) => format!("[{}; {}]", elem_ty.ident(), n),
                    ArrayCount::Prefixed(n) if matches!(**n, FieldType::Varint) => {
                        format!("PrefixedArrayField<VarIntField, {}>", elem_ty.ident())
                    }
                    _ => return None,
                }
                .into()
            }
            Void => "()".into(), // TODO voidfield
            // Uuid => {}
            // EntityMetadata => {}
            Position => format!("PositionField<{}>", protocol_version).into(),
            RestOfBuffer => "RestOfPacketByteArrayField".into(),
            Nbt => "NbtField".into(),
            // OptionalNbt => {}
            Switch(switch) => {
                if let FieldTypeSerialization::GenerateVariableTypes(field, packet) = field {
                    RustType::Generated(VariableType::from_switch(
                        switch,
                        field,
                        packet,
                        protocol_version,
                    ))
                } else {
                    return None;
                }
            }
            // Container(fields) => {}
            // Slot => {}
            // ParticleData => {}
            // Option(_) => {}
            // Bitfield => {}
            // TopBitSetTerminatedArray => {}
            _ => return None,
        })
    }

    fn ident(&self) -> &str {
        match self {
            RustType::Plain(s) => s,
            RustType::Generated(var) => &var.ident,
        }
    }
}

impl VariableType {
    fn from_switch(
        switch: &FieldSwitch,
        field: &Field,
        packet: &Packet,
        protocol_version: u32,
    ) -> Self {
        let ident = format!("{}_{}", packet.name, field.name).to_pascal_case();

        let mut variants = switch
            .cases
            .iter()
            .map(|(val, ty)| {
                let predicate = (switch.predicate_field.clone(), val.to_owned());
                match ty {
                    VoidableType::Void => {
                        // unit
                        (predicate, VariantType::Unit, VariantKind::Standard)
                    }
                    VoidableType::Present(ty) => {
                        // TODO ensure variant types arent generated multiple times - move this into generator and track mapping of (packet,field)->ident
                        let ty = RustType::from_field(
                            FieldTypeSerialization::GenerateVariableTypesCompound(
                                ty, field, packet,
                            ),
                            protocol_version,
                        );
                        let ty = match ty {
                            None => VariantType::Unimplemented,
                            Some(ty) => VariantType::Present(ty),
                        };

                        (predicate, ty, VariantKind::Standard)
                    }
                }
            })
            .collect::<Vec<_>>();

        if let Some(VoidableType::Present(default_ty)) = &switch.default {
            // TODO ensure variant types arent generated multiple times - move this into generator and track mapping of (packet,field)->ident
            let ty = RustType::from_field(
                FieldTypeSerialization::GenerateVariableTypesCompound(default_ty, field, packet),
                protocol_version,
            );

            let idx = variants.len();
            variants.push((
                (String::new(), String::new()),
                VariantType::Unimplemented,
                VariantKind::Default,
            ));
            variants.swap(0, idx); // move to front
        }

        Self {
            ident,
            variants,
            needs_default_unit: matches!(switch.default, Some(VoidableType::Void)),
        }
    }
}

impl From<&'static str> for RustType {
    fn from(str: &'static str) -> Self {
        Self::Plain(Cow::Borrowed(str))
    }
}

impl From<String> for RustType {
    fn from(str: String) -> Self {
        Self::Plain(Cow::Owned(str))
    }
}
