use crate::schema::{FieldType, Packet, PacketDirection, ProtocolVersion};
use displaydoc::Display;
use inflector::Inflector;

use std::fs::File;
use std::io::Write;
use std::path::{Path, PathBuf};

use thiserror::Error;

#[derive(Debug)]
pub struct ModuleGenerator {
    module_dir: PathBuf,
}

pub struct StateGenerator {
    file: File,
    current_mod: Option<PacketDirection>,
}

#[derive(Debug, Display, Error)]
pub enum GeneratorError {
    /// IO error: {0}
    #[error(transparent)]
    Io(#[from] std::io::Error),

    // /// Schema error: {0}
    // Schema(#[from] SchemaError),
    /// Path given is not a directory
    NotADir,

    /// Invalid identifier '{0}'
    BadIdent(String),

    /// Too many duplicate packets with name '{0}'
    TooManyDuplicates(String),
}

pub type GeneratorResult<T> = Result<T, GeneratorError>;

// TODO need to use chat types instead of string types

const COMMON_HEADER: &str = "// autogenerated file\n#![allow(unused_imports)]\n";
const INCLUDES: &str = r#"
use crate::types::*;
use packet_derive::{ClientBoundPacket, ServerBoundPacket};
use async_std::io::Cursor;
use std::fmt::{Display, Formatter};

"#;

impl ModuleGenerator {
    /// Module dir will be **deleted** and have mod.rs created
    pub fn new(module_dir: impl Into<PathBuf>) -> GeneratorResult<Self> {
        let module_dir = module_dir.into();
        if module_dir.exists() && !module_dir.is_dir() {
            return Err(GeneratorError::NotADir);
        }

        if module_dir.exists() {
            std::fs::remove_dir_all(&module_dir)?;
        }
        std::fs::create_dir_all(&module_dir)?;

        Ok(Self { module_dir })
    }

    pub fn emit_version_constants(&self, versions: &ProtocolVersion) -> GeneratorResult<()> {
        let mut mod_rs = self.append_to_mod_rs()?;

        writeln!(
            mod_rs,
            r#"
pub const GAME_VERSION: &str = {:?};
pub const MAJOR_GAME_VERSION: &str = {:?};
pub const PROTOCOL_VERSION: u32 = {};
"#,
            versions.mc_version, versions.major_version, versions.version
        )?;

        Ok(())
    }

    pub fn emit_state(&mut self, state: &str) -> GeneratorResult<StateGenerator> {
        let mut mod_rs = self.append_to_mod_rs()?;
        writeln!(&mut mod_rs, "pub mod {};", state)?;
        StateGenerator::new(&self.module_dir, state).map_err(Into::into)
    }

    fn append_to_mod_rs(&self) -> GeneratorResult<impl std::io::Write> {
        let path = self.module_dir.join("mod.rs");
        let existed = path.exists();
        let mut file = std::fs::OpenOptions::new()
            .create(true)
            .append(true)
            .open(path)?;

        if !existed {
            file.write_all(COMMON_HEADER.as_ref())?;
        }

        Ok(file)
    }
}

impl StateGenerator {
    fn new(mod_dir: &Path, state: &str) -> std::io::Result<Self> {
        let file_name = {
            let mut name = PathBuf::from(state.to_lowercase());
            name.set_extension("rs");
            name
        };
        let mut file = std::fs::OpenOptions::new()
            .create_new(true)
            .write(true)
            .open(mod_dir.join(file_name))?;

        file.write_all(COMMON_HEADER.as_ref())?;
        file.write_all(INCLUDES.as_ref())?;
        Ok(Self {
            file,
            current_mod: None,
        })
    }

    pub fn emit_packet(&mut self, packet: &Packet) -> GeneratorResult<()> {
        if self.current_mod != Some(packet.direction) {
            // new mod
            if self.current_mod.is_some() {
                writeln!(&mut self.file, "}}\n")?;
            }

            let mod_name = match packet.direction {
                PacketDirection::Clientbound => "client",
                PacketDirection::Serverbound => "server",
            };
            writeln!(&mut self.file, "pub mod {} {{\n\tuse super::*;\n", mod_name)?;
            self.current_mod = Some(packet.direction);
        }

        let struct_name = packet.name.to_pascal_case();
        let derive = match packet.direction {
            PacketDirection::Clientbound => "ClientBoundPacket",
            PacketDirection::Serverbound => "ServerBoundPacket",
        };

        let is_incomplete = packet
            .fields
            .iter()
            .any(|f| field_type(&f.r#type).is_none());

        if is_incomplete {
            writeln!(&mut self.file, "/* TODO incomplete struct {}", struct_name)?;
        }

        writeln!(
            &mut self.file,
            "\t#[derive({derive})]\n\t#[packet_id = {id:#04x}]\n\tpub struct {name} {{",
            derive = derive,
            id = packet.id,
            name = struct_name
        )?;

        for field in &packet.fields {
            let ty = field_type(&field.r#type);
            let comment = if ty.is_none() { "// TODO " } else { "" };
            let field_name: syn::Ident = {
                let name = field.name.to_snake_case();
                syn::parse_str(&name)
                    .or_else(|_| syn::parse_str(&format!("r#{}", name)))
                    .map_err(|_| GeneratorError::BadIdent(field.name.to_owned()))?
            };
            write!(
                &mut self.file,
                "\t\t{comment}pub {ident}: ",
                comment = comment,
                ident = field_name,
            )?;

            if let Some(ty) = ty {
                writeln!(&mut self.file, "{},", ty)?;
            } else {
                writeln!(&mut self.file, "{:?},", field.r#type)?;
            }
        }

        let suffix = if is_incomplete { "*/" } else { "" };
        writeln!(&mut self.file, "\t}}\n{}\n", suffix)?;
        Ok(())
    }

    pub fn finish(mut self) -> GeneratorResult<()> {
        if self.current_mod.is_some() {
            writeln!(&mut self.file, "}}\n")?;
        }

        Ok(())
    }
}

fn field_type(ty: &FieldType) -> Option<&'static str> {
    use FieldType::*;
    Some(match ty {
        Varint => "VarIntField",
        U16 => "UShortField",
        U8 => "UByteField",
        I64 => "LongField",
        I32 => "IntField",
        I8 => "ByteField",
        I16 => "ShortField",
        F32 => "FloatField",
        F64 => "DoubleField",
        Bool => "BoolField",
        String => "StringField",
        Buffer { count_ty } if matches!(**count_ty, FieldType::Varint) => {
            "VarIntThenByteArrayField"
        }
        // Array { .. } => {}
        // Uuid => {}
        // EntityMetadata => {}
        // Position => {}
        RestOfBuffer => "RestOfPacketByteArrayField",
        // Nbt => {}
        // OptionalNbt => {}
        // Switch => {}
        // Slot => {}
        // ParticleData => {}
        // Option(_) => {}
        // Bitfield => {}
        // TopBitSetTerminatedArray => {}
        _ => return None,
    })
}
